/**
 * Adapted RedFat benchmark
 **/ 

#include <stdlib.h>
#include <math.h>

#include "StrongAttacker.h"

#define gdMaxColors 256
#define gdTrueColorAlpha(r, g, b, a) (((a) << 24) + \
	((r) << 16) + \
	((g) << 8) + \
	(b))

typedef struct gdImageStruct {
	/* Palette-based image pixels */
	unsigned char ** pixels;
	int sx;
	int sy;
	/* These are valid in palette images only. See also
		'alpha', which appears later in the structure to
		preserve binary backwards compatibility */
	int colorsTotal;
	int red[gdMaxColors];
	int green[gdMaxColors];
	int blue[gdMaxColors];
	int open[gdMaxColors];
	/* For backwards compatibility, this is set to the
		first palette entry with 100% transparency,
		and is also set and reset by the
		gdImageColorTransparent function. Newer
		applications can allocate palette entries
		with any desired level of transparency; however,
		bear in mind that many viewers, notably
		many web browsers, fail to implement
		full alpha channel for PNG and provide
		support for full opacity or transparency only. */
	int transparent;
	int *polyInts;
	int polyAllocated;
	struct gdImageStruct *brush;
	struct gdImageStruct *tile;
	int brushColorMap[gdMaxColors];
	int tileColorMap[gdMaxColors];
	int styleLength;
	int stylePos;
	int *style;
	int interlace;
	/* New in 2.0: thickness of line. Initialized to 1. */
	int thick;
	/* New in 2.0: alpha channel for palettes. Note that only
		Macintosh Internet Explorer and (possibly) Netscape 6
		really support multiple levels of transparency in
		palettes, to my knowledge, as of 2/15/01. Most
		common browsers will display 100% opaque and
		100% transparent correctly, and do something
		unpredictable and/or undesirable for levels
		in between. TBB */
	int alpha[gdMaxColors];
	/* Truecolor flag and pixels. New 2.0 fields appear here at the
		end to minimize breakage of existing object code. */
	int trueColor;
	int ** tpixels;
	/* Should alpha channel be copied, or applied, each time a
		pixel is drawn? This applies to truecolor images only.
		No attempt is made to alpha-blend in palette images,
		even if semitransparent palette entries exist.
		To do that, build your image as a truecolor image,
		then quantize down to 8 bits. */
	int alphaBlendingFlag;
	/* Should antialias functions be used */
	int antialias;
	/* Should the alpha channel of the image be saved? This affects
		PNG at the moment; other future formats may also
		have that capability. JPEG doesn't. */
	int saveAlphaFlag;


	/* 2.0.12: anti-aliased globals */
	int AA;
	int AA_color;
	int AA_dont_blend;
	unsigned char **AA_opacity;
	int AA_polygon;
	/* Stored and pre-computed variables for determining the perpendicular
	 * distance from a point to the anti-aliased line being drawn:
	 */
	int AAL_x1;
	int AAL_y1;
	int AAL_x2;
	int AAL_y2;
	int AAL_Bx_Ax;
	int AAL_By_Ay;
	int AAL_LAB_2;
	float AAL_LAB;

	/* 2.0.12: simple clipping rectangle. These values must be checked for safety when set; please use gdImageSetClip */
	int cx1;
	int cy1;
	int cx2;
	int cy2;
} gdImage;

typedef gdImage * gdImagePtr;

gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, ssize_t bgcolor)
{
	if (bgcolor < 0) {
		return NULL;
	}

	/* impact perf a bit, but not that much. Implementation for palette
	   images can be done at a later point.
	*/
	if (src->trueColor == 0) {
        check((const uint64_t *)&src->alpha[bgcolor]);
        bgcolor = 0;
#if 0
        // Original memory error:
		if (bgcolor >= 0) {
			bgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);
		}
#endif

		// gdImagePaletteToTrueColor(src);
        // make compiler not optimizing the statements out
        return (gdImagePtr)(void *)(long)bgcolor;
	}
	return NULL;
}

/***************************************************************************/

static gdImagePtr im = NULL;

size_t cve_2016_1903_size(void)
{
    return sizeof(gdImage);
}

void cve_2016_1903_init(void *ptr)
{
    im = (gdImagePtr)ptr;
}

void cve_2016_1903(size_t i, bool alt)
{
    const uint64_t *ptr64 = (const uint64_t *)im;
    const uint64_t *end64 = ptr64 + sizeof(*im) / sizeof(uint64_t *);

    if (!alt)
    {
        // Overflow:
        const uint64_t *target = end64 + 1 + i;
        ssize_t bgcolor = ((intptr_t)target - (intptr_t)&im->alpha) /
            sizeof(im->alpha[0]);
        void *res = gdImageRotateInterpolated(im, 11.0, bgcolor);
        fprintf(stderr, "res = %p\n", res);
    }
    else
    {
        // Underflow:
        const uint64_t *target = ptr64 - 1 - i;
        ssize_t bgcolor = ((intptr_t)target - (intptr_t)&im->alpha) /
            sizeof(im->alpha[0]);
        void *res = gdImageRotateInterpolated(im, 11.0, bgcolor);
        fprintf(stderr, "res = %p\n", res);
    }
}

