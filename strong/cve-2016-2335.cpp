/**
 * Adapted RedFat benchmark
 **/

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <vector>

#include "StrongAttacker.h"

struct CLogBlockAddr
{
  u_int32_t Pos;
  ssize_t PartitionRef;
};

struct CLongAllocDesc
{
  u_int32_t Len;
  CLogBlockAddr Location;
};

struct CPartitionMap
{
  uint8_t Type;
  u_int16_t PartitionNumber;
  int PartitionIndex;
};

struct CPartition
{
//  u_int16_t Number;
  uint32_t Pos;
  uint32_t Len;
};

struct CLogVol
{
  uint32_t BlockSize;
  CPartitionMap *PartitionMaps;
};

class CInArchive
{
public:
    std::vector<CPartition> Partitions;
    std::vector<CLogVol> LogVols;
    int ReadFileItem(int volIndex, int fsIndex, const CLongAllocDesc &lad, int numRecurseAllowed);
};

int CInArchive::ReadFileItem(int volIndex, int fsIndex, const CLongAllocDesc &lad, int numRecurseAllowed)
{
  const CLogVol &vol = LogVols[volIndex];
  check((const uint64_t *)(vol.PartitionMaps + lad.Location.PartitionRef));
  // Original overflow:
  // Partitions[vol.PartitionMaps[lad.Location.PartitionRef].PartitionIndex];
  // if (&partition == nullptr)
  //   return 1;
  return 0;
}

/***************************************************************************/

static CPartitionMap  *pm  = nullptr;
static CLongAllocDesc *lad = nullptr;

size_t cve_2016_2335_size(void)
{
    return 2 * sizeof(CPartitionMap);
}

void cve_2016_2335_init(void *ptr)
{
    lad = (CLongAllocDesc *)malloc(sizeof(CLongAllocDesc));
    if (lad == nullptr)
        error("failed to allocate memory: %s", strerror(errno));
    pm = (CPartitionMap *)ptr;  
}

void cve_2016_2335(size_t i, bool alt)
{
    const uint64_t *ptr64 = (const uint64_t *)pm;
    const uint64_t *end64 = ptr64 + cve_2016_2335_size() / sizeof(uint64_t);

    CInArchive cin;
    CLogVol vol;
    vol.PartitionMaps = (CPartitionMap *)pm;
    cin.LogVols.push_back(vol);

	if (!alt)
    {
        // Overflow:
        const uint64_t *target = end64 + 1 + i;
        lad->Location.PartitionRef =
            ((intptr_t)target - (intptr_t)cin.LogVols[0].PartitionMaps) /
            sizeof(CPartition);
        int a = cin.ReadFileItem(0, 2, *lad, 50);
        fprintf(stderr, "a = %d\n", a);
    }
    else
    {
        // Underflow:
        const uint64_t *target = ptr64 - 1 - i;
        lad->Location.PartitionRef =
            ((intptr_t)target - (intptr_t)cin.LogVols[0].PartitionMaps) /
            sizeof(CPartition);
        int a = cin.ReadFileItem(0, 2, *lad, 50);
        fprintf(stderr, "a = %d\n", a);
    }
}

