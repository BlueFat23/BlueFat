/**
 * Adapted RedFat benchmark
 **/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "StrongAttacker.h"

#define DECHAN_MAX_AUG_INDEX 4

typedef signed char gint8;
typedef unsigned char guint8;
typedef unsigned short guint16;

typedef struct sdh_g707_format_s
{
  guint8 m_sdh_line_rate;
  guint8 m_vc_size ;
    gint8 m_vc_index_array[DECHAN_MAX_AUG_INDEX];
        /* i = 4 --> ITU-T letter #E - index of AUG-64
         * i = 3 --> ITU-T letter #D - index of AUG-16
         * i = 2 --> ITU-T letter #C - index of AUG-4,
         * i = 1 --> ITU-T letter #B  -index of AUG-1
         * i = 0 --> ITU-T letter #A  - index of AU3*/
} sdh_g707_format_t;

static int
channelised_fill_sdh_g707_format(sdh_g707_format_t* in_fmt, guint16 bit_flds, guint8 vc_size, ssize_t speed)
{
  int i = 0; /* i = 4 --> ITU-T letter #E - index of AUG-64
              * i = 3 --> ITU-T letter #D - index of AUG-16
              * i = 2 --> ITU-T letter #C - index of AUG-4,
              * i = 1 --> ITU-T letter #B  -index of AUG-1
              * i = 0 --> ITU-T letter #A  - index of AU3*/

  if (0 == vc_size)
  {
    /* unknown / unsed container size*/
    return -1;
  }
  in_fmt->m_vc_size = vc_size;
  in_fmt->m_sdh_line_rate = speed;
  memset(&(in_fmt->m_vc_index_array[0]), 0xff, DECHAN_MAX_AUG_INDEX);

  /* for STM64 traffic, start from #E index shoud be 0 */
  check((const uint64_t *)&in_fmt->m_vc_index_array[ speed - 1]);
#if 0
  // This is the original error:
  in_fmt->m_vc_index_array[ speed - 1] = 0;
#endif

  return 0;     // Return early size speed may be large

  /* for STM64 traffic,from #D and so on .. */
    for (i = (speed - 2); i >= 0; i--)
  {
    guint8 aug_n_index = 0;

    /*if AUG-n is bigger than vc-size*/
    if ( i >= (vc_size - 1))
    {
      /* check the value in bit flds */
      aug_n_index = ((bit_flds >> (2 *i))& 0x3) +1;
    }
    else
    {
      aug_n_index = 0;
    }
    // remove this incremental error to reduce noise
    // in_fmt->m_vc_index_array[i] = aug_n_index;
    fprintf(stderr, "aug_n_index is %d\n", aug_n_index);
  }
  return 0;
}

/***************************************************************************/

static sdh_g707_format_t *im = NULL;

size_t cve_2012_4295_size(void)
{
    return (sizeof(sdh_g707_format_t) < sizeof(void *)?
        sizeof(void *): sizeof(sdh_g707_format_t));
}

void cve_2012_4295_init(void *ptr)
{
    im = (sdh_g707_format_t *)ptr;
}

void cve_2012_4295(size_t i, bool alt)
{
    const uint64_t *ptr64 = (const uint64_t *)im;
    const uint64_t *end64 = ptr64 + sizeof(*im) / sizeof(uint64_t *);

    if (!alt)
    {
        // Overflow:
        const uint64_t *target = end64 + 1 + i;
        ssize_t speed = ((intptr_t)target - (intptr_t)&im->m_vc_index_array) /
            sizeof(im->m_vc_index_array[0]) + 1;
        int res = channelised_fill_sdh_g707_format(im, 10, 10, speed);
        fprintf(stderr, "Res #1 is %d\n", res);
    }
    else
    {
        // Underflow:
        const uint64_t *target = ptr64 - 1 - i;
        ssize_t speed = ((intptr_t)target - (intptr_t)&im->m_vc_index_array) /
            sizeof(im->m_vc_index_array[0]) + 1;
        int res = channelised_fill_sdh_g707_format(im, 10, 10, speed);
        fprintf(stderr, "Res #2 is %d\n", res);
    }
}

